# 9주차 “인기 상품 랭킹 시스템” 구축기

## 1) 왜 만들었나

이커머스에서 “지금 뜨는 상품”을 실시간에 가깝게 보여주고 싶었음.

RDB에서 매번 ORDER BY score DESC로 계산하면 트래픽 피크에서 확장성/지연 문제가 생김.

그래서 집계는 DB, 순위산정과 서빙은 Redis ZSET로 분리하는 구조를 선택.

## 2) 데이터 모델 & 집계 방식

집계 테이블: product_metrics(date, product_id, like_count, sale_quantity, view_count)

각 항목에 대해 가중치를 곱해 하나의 점수를 산출:

```java
public double calculateRankingScore() {
return viewCount * RankingWeight.VIEW.getWeight()
+ likeCount * RankingWeight.LIKE.getWeight()
+ saleQuantity * RankingWeight.SALE.getWeight();
}
```


이렇게 계산된 점수는 RDB에서 ORDER BY로 정렬하기엔 비용이 크기 때문에, Redis의 ZSET(정렬된 집합) 에 저장.

ZSET은 삽입 시점에 점수를 기준으로 자동 정렬되므로, 순위 조회가 자연스럽게 가능하다.

적재 코드 예시:

```java
private final RedisTemplate<String, String> redisTemplate;

redisTemplate.opsForZSet().incrementScore(RedisKeyManager.RankingKeyFor(date),String.valueOf(target.getProductId()),score);
```


이렇게 하면 Redis에서 ZREVRANGE 같은 명령으로 손쉽게 상위 N개의 인기 상품을 가져올 수 있다.


## 3) 서빙 구조: Redis ZSET (일별 키 설계)

키: rank:product:YYYYMMDD → member: productId, score: 가중 합산 점수.

조회:

- Top-N: ZREVRANGE rank:product:20250913 0 19 WITHSCORES
- 단일 순위: ZREVRANK rank:product:20250913 <productId>

Spring Data Redis:

```java
var top = redisTemplate.opsForZSet()
.reverseRangeWithScores(RedisKeyManager.RankingKeyFor(LocalDate.now()), 0, 19);
// 반환 컬렉션은 점수 내림차순 순서가 유지됨
```


## 4) 콜드 스타트 문제 & 해결

문제: 일별 기준으로 랭킹을 만들다 보니, 0시 직후에는 당일 데이터가 충분히 쌓이지 않아 상위 랭킹이 비어 보이거나 불안정해지는 콜드 스타트 문제가 발생한다.

해결 아이디어: 전일 점수의 일부를 다음 날 초기 점수로 감쇠 반영하여 랭킹을 부드럽게 시작한다.

나는 실제로 오늘 점수의 20%를 다음날 랭킹에 미리 반영하도록 했다.

이 작업은 매일 23시 50분 배치에서 실행되며, Redis ZSET에 “익일 키”를 만들어 미리 채워 넣는다.

Redis 예시(오늘 → 내일, 20% 반영):

```redis
# 오늘 랭킹을 내일 랭킹 키로 0.2 가중치로 복제
ZUNIONSTORE rank:product:20250914 1 rank:product:20250913 WEIGHTS 0.2
```


이렇게 해두면 0시가 지나도 내일 랭킹이 최소한의 초기 점수를 가지고 시작하므로, 사용자 경험이 매끄럽다. 이후 당일 실제 데이터가 쌓이면 자연스럽게 덮이며 갱신된다.



## 5) 운영 디테일(핵심만)

- 키 보관: 일별 랭킹 7~14일 TTL.
- 스탬피드 방지: 분산락(SETNX + TTL)으로 합성/Top-N 생성 단일화.
- 파이프라이닝: 대량 ZADD/incrementScore 시 RTT 최소화.
- 정규화/로그 스케일링 검토: 지표 스케일 불균형 완화.
- 모니터링: 상위 N 교체율(churn), 평균/분산, 합성 실행시간, 실패율.

## 6) 이번 주 배운 점

- DB는 소스, 순위는 캐시가 담당해야 성능/확장성/응답속도를 동시에 확보.
- 일별 컷오프 모델은 콜드 스타트가 필연 → 감쇠 기반 워밍업으로 UX를 부드럽게.
- Redis ZSET의 ZUNIONSTORE/ZINTERSTORE로 재가중·합성을 저비용으로 구현 가능.